#include "parser.h"

#include <string>
#include <fstream>
using namespace std;
#include <sstream>
#include <iostream>
#include <sys/stat.h>
#include <iostream>
#include "QString"
#include "QFile"
#include "QTextStream"
#include <stdlib.h>
#include <stdio.h>
#include <typeinfo>
#include <ctype.h>
#include <stdio.h>
#include "nodovar.h"


using std::string;

Parser::Parser()
{
    *i = 0;
}
QJsonObject Parser::parse(string codigo){

    codigoCompleto = codigo;
    std::cout<<"----------------------------SE EMPIEZA A PARSERA -----------------------------"<<std::endl;
    QJsonObject objeto = writeFile(codigo);
    return objeto;
//    imprimirVariables();
 }

QJsonObject Parser::writeFile(string codigo){

    QJsonObject objeto = getType(codigo, lista_valores);
    return objeto;

    }

void Parser::readFile(){

}

void Parser::imprimirVariables(){
    std::cout<<"********************************************************************************"<<std::endl;
    lista_valores.imprimirListaAlDerecho();
    std::cout<<"********************************************************************************"<<std::endl;
}


int Parser::getBlocks(string codigo, VarList *list){

//    std::cout<<"ENCONTRO EL SIGUIENTE BLOQUE"<<std::endl;
//    std::cout<<codigo<<std::endl;

//    struct block b1;
//    string status = "block cerrado";
//    int i = 0;
//    while (i != codigo.size()){

//        if (codigo[i] == '{' && status == "block cerrado"){

//            *b1.inicio = i;
//            status = "block abierto";
//             i = i + 1;
//             continue ;
//        }
//        else if (codigo[i] == '{' && status == "block abierto"){

//            i =  i + getBlocksAnidados(codigo.substr( i, codigo.size()));

//            std::cout<< "Se reubico mi contador en: " << i << ", el cual contiene: " <<codigo[i]<<std::endl;
//            i = i + 1;
//            continue ;

//        }
//        else if(codigo[i]=='}' && status == "block abierto"){
//            std::cout << "Cerro un block en la posicion :" << i << std::endl;
//            std::cout << "Mi bloque final es:"<< std::endl;
//            std::cout << codigo.substr(1,i) << std::endl;
//            *b1.final = i;
//            status = "block cerrado";
//            i = i + 1;
//            break;
//        }
//        else{
//            i =  i + 1;
//            continue ;
//        }
//    }

//    VarList provicional;
//    VarList listaBlock1 = getType(codigo.substr(*b1.inicio + 1,*b1.final + 1 ), provicional);
//    listaBlock1.imprimirListaAlDerecho();

//    BlockList listaBlock2 = copyList(&listaBlock1);

//    listaBlock2.imprimirListaAlDerechoBlock();
//    list->ingresarDatoFinalVar("Tipo block", "Tipo block","Tipo Block",*b1.inicio,*b1.final,"block",codigo.substr(*b1.inicio, *b1.final + 1),listaBlock2);

//    return *b1.final;

}

int Parser::getBlocksAnidados(string codigo){

    std::cout<< "se encontro block anidado" << std::endl;
    struct block b1;
    string status = "block cerrado";
    int i = 0;
    while (i != codigo.size()){

        if (codigo[i] == '{' && status == "block cerrado"){

            *b1.inicio = i;
            status = "block abierto";
            i = i + 1;

        }
        else if(codigo[i]=='}' && status == "block abierto"){
            std::cout << "Cerro un block anidado en la posicion :" << i << ", el cual contiene: " <<codigo[i]<< std::endl;
            *b1.final = i;
            break;
        }
        else if(codigo[i]!='}'){
            i = i + 1;
        }
    }
    std::cout<< "EL SUBLOKE ES :"<<std::endl;

    std::cout<<codigo.substr(0,i + 1 )<<std::endl;
    return *b1.final;
}

string Parser::isStructDef(string codigo){
    int i = 0;

    while(codigo[i] == ' '){
        i = i + 1;
    }
    if(codigo[i] == '{'){
        std::cout<<"^^^^^^ SE VA A CREAR UNA ESTRUCTURA ^^^^"  <<std::endl;
        return "Se crea tipo struct";
    }
    if(codigo[i]!= ';'){
        std::cout<<"^^^^^^ SE VA A INSTANCIAR UNA ESTRUCTURA ^^^^"  <<std::endl;
        return "Se inicializa struct";
    }
}

BlockList Parser::copyList(VarList *listaVar){

    BlockList lista;
    NodoVar *corredor  = listaVar->primero;
    lista.ingresarDatoFinalBlock(corredor->variable,corredor->valor, corredor->tipo,-10,-10,"variable","Tipo Variable");
    corredor = corredor->siguiente;
    while (corredor != listaVar->primero) {

        lista.ingresarDatoFinalBlock(corredor->variable,corredor->valor, corredor->tipo,-10,-10,"variable","Tipo Variable");
        corredor = corredor->siguiente;
    }
    return lista;
}
QJsonObject Parser::makeJson(string tip, string val, string var){
    QJsonObject object
        {
            {"Type","NI"},
            {"Value","NI"},
            {"Variable","NI"}
        };

        QVariant tipo(QString::fromStdString(tip));
        QVariant valor(QString::fromStdString(val));
        QVariant variable(QString::fromStdString(var));

        object.insert("Type",tipo.toJsonValue());
        object.insert("Value",valor.toJsonValue());
        object.insert("Variable",variable.toJsonValue());
        return object;
}

QJsonObject Parser::getType(string codigo, VarList &lista_var){
    do{
        std::cout << "EL I MIO ES:"<< *i << std::endl;
        if(codigo[*i] == 'i'){
            if(codigo.substr(*i,4) == "int "){

                string variable  = getVariable(codigo.substr(*i + 4,codigo.size()));

                bool tieneDot = checkDotSing(codigo.substr(*i + 4 + variable.size(),codigo.size()));

                bool tieneIgual = checkEqualSing(codigo.substr(*i + 4 + variable.size(),codigo.size()));

                if(tieneIgual == true){

                    string valor = getValor(codigo.substr(*i+6+variable.size(),codigo.size()), "int", lista_var);

                    try{

                        int *x = getReubicador(codigo.substr(*i,codigo.size()));
                        std::cout << "SE REUBICA EN:"<< codigo[*x] << std::endl;
                        *i = *i + *x + 1;
                    }
                        catch(int e){
                            std::cout<< "NO SE PUDO REUBICAR"<<std::endl;
                        }
                    QJsonObject  objeto = makeJson("int",valor,variable);
                    return objeto;

            }


                else if(tieneDot == true){
                    std::cout<<"VARIABLE NO INICIALIZADA"<<std::endl;

                    try{
                        int *x = getReubicador(codigo.substr(*i,codigo.size()));

                        *i = *i + *x;
                    }
                        catch(int e){
                            std::cout<< "NO SE PUDO REUBICAR"<<std::endl;
                        }
                    QJsonObject  objeto = makeJson("int","NI",variable);
                    return objeto;
                }


           }
            *i = *i +1;
        }
        else if(codigo[*i]=='f'){
            if(codigo.substr(*i,6) == "float "){

                string variable  = getVariable(codigo.substr(*i + 5,codigo.size()));
                bool tieneIgual = checkEqualSing(codigo.substr(*i + 6 + variable.size(),codigo.size()));
                bool tieneDot = checkDotSing(codigo.substr(*i + 6 + variable.size(),codigo.size()));
                string valor = getValor(codigo.substr(*i+8+variable.size(),codigo.size()),"float", lista_var);




                if(tieneIgual == true){


                    try{
                        int *x = getReubicador(codigo.substr(*i,codigo.size()));

                        *i = *i + *x;
                    }
                        catch(int e){
                            std::cout<< "NO SE PUDO REUBICAR"<<std::endl;
                        }
                    QJsonObject  objeto = makeJson("float",valor,variable);
                    return objeto;
                }

                else if(tieneDot == true){

                    try{
                        int *x = getReubicador(codigo.substr(*i,codigo.size()));

                        *i = *i + *x;
                    }
                        catch(int e){
                            std::cout<< "NO SE PUDO REUBICAR"<<std::endl;
                    }
                    QJsonObject  objeto = makeJson("float","NI",variable);
                    return objeto;
                }


            }

        }
        else if(codigo[*i]=='l'){
            if(codigo.substr(*i,5) == "long "){

                string variable  = getVariable(codigo.substr(*i + 5,codigo.size()));
                bool tieneIgual = checkEqualSing(codigo.substr(*i + 5 + variable.size(),codigo.size()));
                bool tieneDot = checkDotSing(codigo.substr(*i + 6 + variable.size(),codigo.size()));
                string valor = getValor(codigo.substr(*i+7+variable.size(),codigo.size()),"long", lista_var);

                if(tieneIgual == true){

                    try{
                        int *x = getReubicador(codigo.substr(*i,codigo.size()));

                        *i = *i + *x;
                    }
                        catch(int e){
                            std::cout<< "NO SE PUDO REUBICAR"<<std::endl;
                        }
                    QJsonObject  objeto = makeJson("long",valor,variable);
                    return objeto;
                }
                if(tieneDot == true){

                    try{
                        int *x = getReubicador(codigo.substr(*i,codigo.size()));

                        *i = *i + *x;
                    }
                        catch(int e){
                            std::cout<< "NO SE PUDO REUBICAR"<<std::endl;
                        }
                    QJsonObject  objeto = makeJson("long","NI",variable);
                    return objeto;
                }


            }

        }
        else if(codigo[*i]=='d'){
            if(codigo.substr(*i,7) == "double "){

                string variable  = getVariable(codigo.substr(*i + 7,codigo.size()));
                bool tieneIgual = checkEqualSing(codigo.substr(*i + 7 + variable.size(),codigo.size()));
                bool tieneDot = checkDotSing(codigo.substr(*i + 6 + variable.size(),codigo.size()));
                string valor = getValor(codigo.substr(*i+9+variable.size(),codigo.size()),"double",lista_var);



                if(tieneIgual == true){


                    try{
                        int *x = getReubicador(codigo.substr(*i,codigo.size()));

                        *i = *i + *x;
                    }
                        catch(int e){
                            std::cout<< "NO SE PUDO REUBICAR"<<std::endl;
                        }
                    QJsonObject  objeto = makeJson("double",valor,variable);
                    return objeto;
                }
                else if(tieneDot == true){

                    try{
                        int *x = getReubicador(codigo.substr(*i,codigo.size()));

                        *i = *i + *x;
                    }
                        catch(int e){
                            std::cout<< "NO SE PUDO REUBICAR"<<std::endl;
                        }
                    QJsonObject  objeto = makeJson("double","NI",variable);
                    return objeto;
                }
            }

        }
        else if(codigo[*i]=='c'){
            if(codigo.substr(*i,5) == "char "){

                string variable  = getVariable(codigo.substr(*i + 4,codigo.size()));
                bool tieneIgual = checkEqualSing(codigo.substr(*i + 5 + variable.size(),codigo.size()));
                bool tieneDot = checkDotSing(codigo.substr(*i + 6 + variable.size(),codigo.size()));
                string valor = getValor(codigo.substr(*i+7+variable.size(),codigo.size()),"char", lista_var);


                if(tieneIgual == true){


                    try{
                        int *x = getReubicador(codigo.substr(*i,codigo.size()));

                        *i = *i + *x;
                    }
                        catch(int e){
                            std::cout<< "NO SE PUDO REUBICAR"<<std::endl;
                        }
                    QJsonObject  objeto = makeJson("char",valor,variable);
                    return objeto;
                }
                else if(tieneDot == true){

                    try{
                        int *x = getReubicador(codigo.substr(*i,codigo.size()));

                        *i = *i + *x;
                    }
                        catch(int e){
                            std::cout<< "NO SE PUDO REUBICAR"<<std::endl;
                        }
                    QJsonObject  objeto = makeJson("char","NI",variable);
                    return objeto;
                }
            }

        }
        else if(codigo[*i] == 's' ){

            if(codigo.substr(*i,7) == "struct "){

                string variable  = getVariable(codigo.substr(*i + 6,codigo.size()));
                string *variable3  = (string *)malloc(sizeof(string));
                *variable3 = variable;

                if(isStructDef(codigo.substr(*i + 7 + variable.size(), codigo.size())) == "Se crea tipo struct"){

                    struct block bk = analizarStruct(codigo.substr(*i + 7 + variable.size(), codigo.size()),&lista_var, variable);

                    QJsonObject  objeto = makeJson("struct",std::to_string(*bk.inicio),std::to_string(*bk.final));
                    return objeto;
                }

//                else if(isStructDef(codigo.substr(i + 7 + variable.size(), codigo.size())) == "Se inicializa struct"){
//                    string variable  = getVariable(codigo.substr(i + 7,codigo.size()));

//                    if(lista_var.buscarNodo(variable)->variable != "NO SE ENCONTRO"){
//                        BlockList listaBlock;
//                        BlockList listaBlock2  = lista_var.buscarNodo(variable)->lista;
//                        BlockList listaBlockFinal = copyStructList(listaBlock2,listaBlock);

//                        string variable2 = getValor(codigo.substr(i + 7 + variable.size(),codigo.size()),"Struct", lista_var);
//                        std::cout<<"SE ENCONTRO QUE SE QUIERE INICIALIZAR LA SIGUIENTE ESTRUCTURA :"<<variable2<<std::endl;
//                        lista_var.ingresarDatoFinalVar(variable2, *variable3,"Variable Struct",-10,-10,"Variable Struct","Variable Struct",listaBlockFinal);
//                        i = i + 8 + variable2.size();
//                    }

//                }
            }
             i = i +1;
        }

//        else if(codigo[i]=='{' ){

//            i  =  i + getBlocks(codigo.substr(i, codigo.size()),&lista_var);

//        }




//        else if (buscarNum(getVariable(codigo.substr(i ,codigo.size())),lista_var)->variable != "NO SE ENCONTRO"){
//            std::cout<< "ENCONTRO UNA ASIGNACION DE VARIABLE"<<std::endl;

//            string variable = getVariable(codigo.substr(i ,codigo.size())); //Da el nombre de la variable
//            NodoVar *nodox = buscarNum(getVariable(codigo.substr(i ,codigo.size())),lista_var);
//            string variable_dentro_lista = getVariable(codigo.substr(i + nodox->variable.size() + 1   ,codigo.size()));

//            string valor = getValor(codigo.substr(i  + variable.size() + variable_dentro_lista.size() + 3,codigo.size()),nodox->tipo, lista_var);


//            if(nodox->tipo == "Variable Struct" && codigo[i + variable.size()] == '.'){
//                std::cout<<"FUNCIONOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO"<<std::endl;
//                nodox->lista.imprimirListaAlDerechoBlock();
//                BlockNode *nodo_dentro_lista = nodox->lista.buscarNodo(variable_dentro_lista);
//                std::cout<<"NODO_DENTRO_LISTA: "<<nodo_dentro_lista->valor<<std::endl;
//                nodo_dentro_lista->valor = valor;
//                try{
//                    int x = *getReubicador(codigo.substr(i,codigo.size()));
//                    std::cout<< "Se reubico mi contador en: "<<codigo[i + x ]<<std::endl;
//                    i = i + x;
//                }
//                    catch(int e){
//                        std::cout<< "NO SE PUDO REUBICAR"<<std::endl;
//                    }
//            }

//            else if (nodox->tipo != "Variable Struct"){
//                NodoVar *nodox = buscarNum(getVariable(codigo.substr(i ,codigo.size())),lista_var);
//                valor = getValor(codigo.substr(i + nodox->variable.size() + 2,codigo.size()),nodox->tipo, lista_var);
//                nodox->valor = valor;

//                try{
//                    int x = *getReubicador(codigo.substr(i,codigo.size()));
//                    std::cout<< "Se reubico mi contador en: "<<codigo[i + x ]<<std::endl;
//                    i = i + x;
//                }
//                catch(int e){
//                    std::cout<< "NO SE PUDO REUBICAR"<<std::endl;
//                }
//            }



        else{
            *i = *i +1;
        }

    }while(*i!= codigo.size());

}

BlockList Parser::copyStructList(BlockList lista1, BlockList lista2){
        if(lista1.largo == 0){
            return lista2;
        }

    BlockNode *corredor  = lista1.primero;
    lista2.ingresarDatoFinalBlock(corredor->variable,corredor->valor, corredor->tipo,-10,-10,"variable","Tipo Variable");
    corredor = corredor->siguiente;
    while (corredor != lista1.primero) {

        lista2.ingresarDatoFinalBlock(corredor->variable,corredor->valor, corredor->tipo,-10,-10,"variable","Tipo Variable");
        corredor = corredor->siguiente;
    }
    return lista2;

}


struct block Parser::analizarStruct(string codigo, VarList *list, string variable){


    struct block b1;
    string status = "block cerrado";
    int j = 0;
    while (j != codigo.size()){

        if (codigo[j] == '{' && status == "block cerrado"){

            *b1.inicio = *i + j;
            status = "block abierto";
             j = j + 1;
             continue ;
        }

        else if(codigo[j]=='}' && status == "block abierto"){
            std::cout << "Cerro un block en la posicion :" << j << std::endl;
            std::cout << "Mi bloque final es:"<< std::endl;
            std::cout << codigo.substr(1,j) << std::endl;
            *b1.final = *i + j;
            status = "block cerrado";
            j = j + 1;
            break;
        }
        else{
            j =  j + 1;
            continue ;
        }
    }

    return b1;
}




string Parser::getVariable(string codigo){

    string variable = "";
    int i = 0;
    while(codigo[i] == ' '){
        i = i + 1;
    }
    while(codigo[i]!= ' ' && codigo[i]!= ';' && codigo[i]!= '.'){
        variable = variable + codigo[i];
        i = i + 1;
    }
    return variable;
}







bool Parser::checkEqualSing(string codigo){

    int i = 0;

    while(codigo[i] == ' '){
        i = i + 1;
    }
    if(codigo[i] == '='){

        return true;
    }
    if(codigo[i]!= '='){

        return false;
    }
}

bool Parser::checkDotSing(string codigo){
    int i = 0;

    while(codigo[i] == ' '){
        i = i + 1;
    }
    if(codigo[i] == ';'){

        return true;
    }
    if(codigo[i]!= ';'){

        return false;
    }

}






int *Parser::getVariableSize(string codigo){

    string variable = "";
    int *i  = (int*)malloc(sizeof(int));
    *i = 0;
    while(codigo[*i] == ' '){
        *i = *i + 1;
    }
    *i = 0;
    while(codigo[*i]!= ' '){
        variable = variable + codigo[*i];
        *i = *i + 1;
    }
    return i;
}

string Parser::getValor(string codigo, string tipo, VarList lista_Var){

    string valor = "";
    int i = 0;
    while(codigo[i] == ' '){
        i = i + 1;
    }
    while(codigo[i]!= ';'){
        valor = valor + codigo[i];
        i = i + 1;
    }
    return valor;
}

int *Parser::getReubicador(string codigo){
    int *i = (int *)malloc(sizeof(int));
    *i = 0;
    while(codigo[*i] != ';'){
        *i = *i +1;
    }
    return i;
}






bool Parser::verificarTipo(string tipo ,string valor){

    if(tipo == "int"){

        if(typeid (atoi( valor.c_str() )).name() == typeid(9).name()){
            return true;
        }
        else{
            return false;
        }
    }

    if(tipo == "long"){

        if(typeid (atol(valor.c_str())).name() == typeid(4294967296).name()){
            return true;
        }
        else{
            return false;
        }
    }
    if(tipo == "float"){

        if(typeid (strtof((valor).c_str(),0)).name() == typeid(3.5F).name()){
            return true;
        }
        else{
            return false;
        }
    }
    if(tipo == "double"){

        if(typeid (atof(valor.c_str())).name() == typeid(8.99999999999996).name()){
            return true;
        }
        else{
            return false;
        }
    }
    if(tipo == "char"){

        if(valor[0] == '"' && valor[valor.size()-1] == '"'){
            return true;
        }
        else{
            return false;
        }
    }
}





string Parser::analizarValor(string valor, VarList listaVar){

    std::cout<<"++++++++++++++++++++++++++++++++++   se metio a analizar con :" <<valor<<" ++++++++++++++++++++++++++++++++++++"<<std::endl;
    listaVar.imprimirListaAlDerecho();
    valor= valor + ";";

    if (valor.find('+')!= std::string::npos){

        std::cout<<"SE METIO A SUMAR :" <<valor<<std::endl;
        string num1 = getNumbers(valor.substr(0,valor.find('+') + 1));

        string num2 = getNumbers(valor.substr(valor.find('+') + 1, valor.size()));
        std::cout<<"num1 = "<<num1<<", num2 = "<<num2 <<std::endl;
        int p = 0;
        string estado_num1 ="es numero";
        string estado_num2 ="es numero";

        while(p!= num1.size()){
            char x  = num1[p];
            std::cout<<"EL CARACTER A EVALUAR ES: "<<x<<std::endl;
            if (!isdigit(x) ){

                estado_num1 = "no es numero";
                break;
            }
            p = p +1;
        }
        int j = 0;
        while(j != num2.size()){
            char y  = num2[j];
            if (!isdigit(y)){

                estado_num2= "no es numero";
                break;
            }
            j = j + 1;
        }
        std::cout<<"LOS ESTADOS DE MI NUMERO SON: "<<estado_num1 <<", " << estado_num2<<std::endl;


        if(estado_num1 == "es numero" && estado_num2 == "es numero"){
            NodoVar *nodo = buscarNum(num1,  listaVar);
            int numeroBuscado = obtenerNumero(nodo);
            std::cout<<numeroBuscado << std::endl;
            int suma = (atoi( num1.c_str()) + atoi( num2.c_str() ));
            return to_string(suma);
        }
        else if(estado_num1 == "es numero" && estado_num2 == "no es numero"){
            NodoVar *nodo = buscarNum(num2,  listaVar);
            int numeroBuscado = obtenerNumero(nodo);
            if(nodo->valor == "NO SE ENCONTRO"){
                return "NO SE ENCONTRO";
            }
            int suma  = (atoi( num1.c_str()) + numeroBuscado);
            return to_string(suma);
        }
        else if(estado_num1 == "no es numero" && estado_num2 == "es numero"){
            NodoVar *nodo = buscarNum(num1,  listaVar);
            int numeroBuscado = obtenerNumero(nodo);
            if(nodo->valor == "NO SE ENCONTRO"){
                return "NO SE ENCONTRO";
            }
            int suma = (atoi( num2.c_str()) + numeroBuscado);
            return to_string(suma);
        }
        else if(estado_num1 == "no es numero" && estado_num2 == "no es numero"){

            NodoVar *nodo1 = buscarNum(num1,  listaVar);
            int numeroBuscado1 = obtenerNumero(nodo1);
            NodoVar *nodo2 = buscarNum(num2,  listaVar);
            int numeroBuscado2 = obtenerNumero(nodo2);
            std::cout <<"NINGUNO DE LOS DOS SON NUMEROS, Y TIENEN: " <<nodo1->valor<<" , "<<nodo2->valor<<std::endl;
            if(nodo1->valor == "NO SE ENCONTRO" || nodo2->valor == "NO SE ENCONTRO"){
                return "NO SE ENCONTRO";
            }
            int suma = (numeroBuscado1 + numeroBuscado2);
            return to_string(suma);

        }

    }
    else if (valor.find('-')!= std::string::npos){
        std::cout<<"VA A RESTAR"<<std::endl;
        string num1 = getNumbers(valor.substr(0,valor.find('-') + 1));

        string num2 = getNumbers(valor.substr(valor.find('-') + 1, valor.size()));
        std::cout<<"NUM1: |" << num1 <<"|"<<std::endl;
        std::cout<<"NUM2: |" << num2 <<"|"<<std::endl;
        int p = 0;
        string estado_num1 ="es numero";
        string estado_num2 ="es numero";

        while(p!= num1.size()){
            char x  = num1[p];
            std::cout<<"EL CARACTER A EVALUAR ES: "<<x<<std::endl;
            if (!isdigit(x) ){

                estado_num1 = "no es numero";
                break;
            }
            p = p +1;
        }
        int j = 0;
        while(j != num2.size()){
            char y  = num2[j];
            if (!isdigit(y)){

                estado_num2= "no es numero";
                break;
            }
            j = j + 1;
        }

        std::cout<<"LOS ESTADOS DE MI NUMERO SON: "<<estado_num1 <<", " << estado_num2<<std::endl;

        if(estado_num1 == "es numero" && estado_num2 == "es numero"){

            int suma = (atoi( num1.c_str()) - atoi( num2.c_str() ));
            return to_string(suma);
        }
        else if(estado_num1 == "es numero" && estado_num2 == "no es numero"){
            NodoVar *nodo = buscarNum(num2,  listaVar);
            int numeroBuscado = obtenerNumero(nodo);
            if(nodo->valor == "NO SE ENCONTRO"){
                return "NO SE ENCONTRO";
            }
            int suma  = (atoi( num1.c_str()) - numeroBuscado);
            return to_string(suma);
        }
        else if(estado_num1 == "no es numero" && estado_num2 == "es numero"){
            NodoVar *nodo = buscarNum(num1,  listaVar);
            std::cout <<"AHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH: "<<nodo->variable <<std::endl;
            int numeroBuscado = obtenerNumero(nodo);
            if(nodo->valor == "NO SE ENCONTRO"){
                return "NO SE ENCONTRO";
            }
            int suma = (atoi( num2.c_str()) - numeroBuscado);
            return to_string(suma);
        }
        else if(estado_num1 == "no es numero" && estado_num2 == "no es numero"){
            NodoVar *nodo1 = buscarNum(num1,  listaVar);
            int numeroBuscado1 = obtenerNumero(nodo1);
            NodoVar *nodo2 = buscarNum(num2,  listaVar);
            int numeroBuscado2 = obtenerNumero(nodo2);
            if(nodo1->valor == "NO SE ENCONTRO" || nodo2->valor == "NO SE ENCONTRO"){
                return "NO SE ENCONTRO";
            }
            int suma = (numeroBuscado1 - numeroBuscado2);
            return to_string(suma);

        }
    }
    else if (valor.find('/')!= std::string::npos){
        std::cout<<"VA A DIVIDIR"<<std::endl;
        string num1 = getNumbers(valor.substr(0,valor.find('/') + 1));

        string num2 = getNumbers(valor.substr(valor.find('/') + 1, valor.size()));
        std::cout<<"NUM1: |" << num1 <<"|"<<std::endl;
        std::cout<<"NUM2: |" << num2 <<"|"<<std::endl;
        int p = 0;
        string estado_num1 ="es numero";
        string estado_num2 ="es numero";

        while(p!= num1.size()){
            char x  = num1[p];
            std::cout<<"EL CARACTER A EVALUAR ES: "<<x<<std::endl;
            if (!isdigit(x) ){

                estado_num1 = "no es numero";
                break;
            }
            p = p +1;
        }
        int j = 0;
        while(j != num2.size()){
            char y  = num2[j];
            if (!isdigit(y)){

                estado_num2= "no es numero";
                break;
            }
            j = j + 1;
        }
        std::cout<<"LOS ESTADOS DE MI NUMERO SON: "<<estado_num1 <<", " << estado_num2<<std::endl;
        if(estado_num1 == "es numero" && estado_num2 == "es numero"){

            int suma = (atoi( num1.c_str()) / atoi( num2.c_str() ));
            return to_string(suma);
        }
        else if(estado_num1 == "es numero" && estado_num2 == "no es numero"){
            NodoVar *nodo = buscarNum(num2,  listaVar);
            int numeroBuscado = obtenerNumero(nodo);
            if(nodo->valor == "NO SE ENCONTRO"){
                return "NO SE ENCONTRO";
            }
            int suma  = (atoi( num1.c_str()) / numeroBuscado);
            return to_string(suma);
        }
        else if(estado_num1 == "no es numero" && estado_num2 == "es numero"){
            NodoVar *nodo = buscarNum(num1,  listaVar);
            int numeroBuscado = obtenerNumero(nodo);
            if(nodo->valor == "NO SE ENCONTRO"){
                return "NO SE ENCONTRO";
            }
            int suma = (atoi( num2.c_str())  / numeroBuscado);
            return to_string(suma);
        }
        else if(estado_num1 == "no es numero" && estado_num2 == "no es numero"){
            NodoVar *nodo1 = buscarNum(num1,  listaVar);
            int numeroBuscado1 = obtenerNumero(nodo1);
            NodoVar *nodo2 = buscarNum(num2,  listaVar);
            int numeroBuscado2 = obtenerNumero(nodo2);
            if(nodo1->valor == "NO SE ENCONTRO" || nodo2->valor == "NO SE ENCONTRO"){
                return "NO SE ENCONTRO";
            }
            int suma = (numeroBuscado1 / numeroBuscado2);
            return to_string(suma);

        }


    }
    else if (valor.find('%')!= std::string::npos){

        string num1 = getNumbers(valor.substr(0,valor.find('%') + 1));



        string num2 = getNumbers(valor.substr(valor.find('%') + 1, valor.size()));
        int p = 0;
        string estado_num1 ="es numero";
        string estado_num2 ="es numero";
        while(p!= num1.size()){
            char x  = num1[p];
            std::cout<<"EL CARACTER A EVALUAR ES: "<<x<<std::endl;
            if (!isdigit(x) ){

                estado_num1 = "no es numero";
                break;
            }
            p = p +1;
        }
        int j = 0;
        while(j != num2.size()){
            char y  = num2[j];
            if (!isdigit(y)){

                estado_num2= "no es numero";
                break;
            }
            j = j + 1;
        }
        std::cout<<"LOS ESTADOS DE MI NUMERO SON: "<<estado_num1 <<", " << estado_num2<<std::endl;
        if(estado_num1 == "es numero" && estado_num2 == "es numero"){

            int suma = (atoi( num1.c_str()) % atoi( num2.c_str() ));
            return to_string(suma);
        }
        else if(estado_num1 == "es numero" && estado_num2 == "no es numero"){
            NodoVar *nodo = buscarNum(num2,  listaVar);
            int numeroBuscado = obtenerNumero(nodo);
            if(nodo->variable == "NO SE ENCONTRO"){
                return "NO SE ENCONTRO";
            }
            int suma  = (atoi( num1.c_str()) % numeroBuscado);
            return to_string(suma);
        }
        else if(estado_num1 == "no es numero" && estado_num2 == "es numero"){
            NodoVar *nodo = buscarNum(num1,  listaVar);
            int numeroBuscado = obtenerNumero(nodo);
            if(nodo->variable == "NO SE ENCONTRO"){
                return "NO SE ENCONTRO";
            }
            int suma = (atoi( num2.c_str()) % numeroBuscado);
            return to_string(suma);
        }
        else if(estado_num1 == "no es numero" && estado_num2 == "no es numero"){
            NodoVar *nodo1 = buscarNum(num1,  listaVar);
            int numeroBuscado1 = obtenerNumero(nodo1);
            NodoVar *nodo2 = buscarNum(num2,  listaVar);
            int numeroBuscado2 = obtenerNumero(nodo2);
            if(nodo1->valor == "NO SE ENCONTRO" || nodo2->valor == "NO SE ENCONTRO"){
                return "NO SE ENCONTRO";
            }
            int suma = (numeroBuscado1 % numeroBuscado2);
            return to_string(suma);

        }
    }
    else{

    }
}

int Parser::obtenerNumero(NodoVar *nodo){

    if(nodo->tipo == "int"){
        return atoi(nodo->valor.c_str());
    }
    if(nodo->tipo == "float"){
        return strtof((nodo->valor).c_str(),0);
    }
    if(nodo->tipo == "long"){
        return atol(nodo->valor.c_str());
    }
    if(nodo->tipo == "double"){
        return atof(nodo->valor.c_str());
    }
}


NodoVar *Parser::buscarNum(string nombre_de_variable, VarList listaVar){

  std::cout<<"SE METIO A BUSCAR LA VARIABLE:" << nombre_de_variable << std::endl;


  NodoVar *nodo = lista_valores.buscarNodo(nombre_de_variable);
  string valor_en_scope = listaVar.buscarNodo(nombre_de_variable)->variable;
  std::cout<<"EN SCOPE:" << valor_en_scope << std::endl;
  std::cout<<"NODO:" << nodo->variable<< std::endl;

  if(nodo->variable == "NO SE ENCONTRO" && valor_en_scope == "NO SE ENCONTRO"){
      std::cout<<"NO SE ENCONTRO EL DATO BUSCADO" << std::endl;
      BlockList listaprov;
      NodoVar* nodox = new NodoVar(" "," "," ",-10,-10," "," ",listaprov);
      nodox->valor = "NO SE ENCONTRO";
      nodox->variable = "NO SE ENCONTRO";
      return nodox;
  }
  else if(nodo->variable == "NO SE ENCONTRO" && valor_en_scope != "NO SE ENCONTRO"){
      nodo = listaVar.buscarNodo(nombre_de_variable);
      return nodo;
  }
  else{
      return nodo;
  }
}

string Parser::getNumbers(string number){
    string valor = "";
    int i = 0;
    while(number[i] == ' '){
        i = i + 1;
    }

    while(number[i]!= '+' && number[i]!= ' ' && number[i]!= ';' && number[i]!= '-' && number[i]!= '/'&& number[i]!= '%'){

        valor = valor + number[i];
        i = i + 1;
    }

    return valor;
}






































